#! /usr/bin/env python
# encoding: utf-8

import os, sys
import re
import shutil
import errno
from waflib.Errors import WafError

def build(ctx):
    ctx.env.RPATH_zcm = [ctx.path.get_bld().abspath()]

    srcExcludes = ['transport/third-party/embedded']
    if not ctx.env.USING_THIRD_PARTY:
        srcExcludes.append('transport/third-party')

    ctx.shlib(target = 'zcm',
              # Note: Had to make the include path one level up so that includes
              #       within this directory structure would match the structure
              #       of the installed files. Includes should be written as:
              #       #include "zcm/file.h".
              includes = '..',
              export_includes = '..',
              use = ['default', 'zmq'],
              source = ctx.path.ant_glob(['*.cpp', '*.c',
                                          'util/*.c', 'util/*.cpp',
                                          'tools/*.c', 'tools/*.cpp',
                                          'json/jsoncpp.cpp',
                                          'transport/**/*.c', 'transport/**/*.cpp'],
                                          excl=srcExcludes))


    embedSource = ['zcm.h', 'zcm_private.h', 'zcm.c', 'zcm-cpp.hpp', 'zcm-cpp-impl.hpp',
                   'zcm_coretypes.h', 'transport.h', 'nonblocking.h', 'nonblocking.c',
                   'transport/generic_serial_transport.h',
                   'transport/generic_serial_transport.c' ]

    if ctx.env.USING_THIRD_PARTY:
        embedSource.append('transport/third-party/embedded/**')

    embedSource = ctx.path.ant_glob(embedSource)
    embedSource.append(ctx.path.find_or_declare("../zcm.gitid"))

    ## Collect files for Embedded
    ctx(rule   = package_embedded,
        name   = 'embed-tar',
        source = embedSource,
        target = 'zcm-embed.tar.gz',
        color  = "PINK")

    ## Test the embedded export
    ctx(rule   = exec_test_embedded,
        source = 'zcm-embed.tar.gz',
        target = 'zcm-embed-tests',
        color  = "PINK",
        after  = 'embed-tar-finish')

    ctx.install_files('${PREFIX}/include/zcm',
                      ['zcm.h', 'zcm_coretypes.h', 'transport.h', 'transport_registrar.h',
                       'url.h', 'eventlog.h', 'zcm-cpp.hpp', 'zcm-cpp-impl.hpp',
                       'transport_register.hpp', 'message_tracker.hpp'])

    ctx.install_files('${PREFIX}/include/zcm/tools',
                      ['tools/IndexerPlugin.hpp',
                       'tools/TranscoderPlugin.hpp'])

    ctx.install_files('${PREFIX}/include/zcm/util', 'util/Filter.hpp')

    ctx.install_files('${PREFIX}/include/zcm/json',
                      ['json/json.h', 'json/json-forwards.h'])

    ctx.install_files('${PREFIX}/include/zcm/transport',
                      ['transport/generic_serial_transport.h'])

    ctx.recurse('util')

    if ctx.env.USING_JAVA:
        ctx.recurse('java');

    if ctx.env.USING_NODEJS:
        ctx.recurse('js');

    if ctx.env.USING_PYTHON:
        ctx.recurse('python')

    if ctx.env.USING_CXXTEST:
        ctx.cxxtest(use = ['zcm', 'testzcmtypes'])

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def package_embedded(tsk):
    gen = tsk.generator
    bld = gen.bld


    outfile = bld.path.get_bld().abspath() + '/' + tsk.outputs[0].relpath()
    outdir = re.sub('\.tar.gz$', '', outfile)

    shutil.rmtree(outdir, ignore_errors = True)
    mkdir_p(outdir + '/zcm')

    for f in tsk.inputs:
        srcDest = outdir + '/zcm/' + os.path.relpath(f.abspath(), bld.path.abspath())
        mkdir_p(os.path.dirname(srcDest))
        shutil.copyfile(f.abspath(), srcDest)

    cmd = '{0}/scripts/prepend-embed-guards.sh {1}/zcm && \
           find {1}/zcm -name "*.old" -type f -delete && \
           tar -czf {2} -C {1} zcm'.format(bld.path.abspath(), outdir, outfile)

    ret = tsk.exec_command(cmd)
    if ret is not 0:
        raise WafError('Unable to package embedded tarball')

    for f in tsk.inputs:
        srcDest = outdir + '/zcm/' + os.path.relpath(f.abspath(), bld.path.abspath())

    return 0

def exec_test_embedded(tsk):
    src = tsk.inputs[0].abspath()
    blddir =  os.path.dirname(src)
    testdir = blddir + '/test-embed'
    cmd = 'rm -rf {0} && mkdir {0} && cd {0} && tar -xf {1} && ' \
          'cc -std=c89 -I ./zcm -DZCM_EMBEDDED -c zcm/zcm/*.c && ' \
          'echo "embed passed" > {2}' \
          .format(testdir, src, tsk.outputs[0].abspath())

    ret = tsk.exec_command(cmd)
    if ret is not 0:
        raise WafError('Embedded build failed, check embedded core files for C89 compliance')
    return ret
