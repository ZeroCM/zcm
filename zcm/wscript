#! /usr/bin/env python
# encoding: utf-8

import os, sys
import re
from waflib.Errors import WafError

def build(ctx):
    ctx.env.RPATH_zcm = [ctx.path.get_bld().abspath()]

    srcExcludes = ['transport/third-party/embedded']
    if not ctx.env.USING_THIRD_PARTY:
        srcExcludes.append('transport/third-party')

    ctx.shlib(target = 'zcm',
              # Note: Had to make the include path one level up so that includes
              #       within this directory structure would match the structure
              #       of the installed files. Includes should be written as:
              #       #include "zcm/file.h".
              includes = '..',
              export_includes = '..',
              use = ['default', 'zmq'],
              source = ctx.path.ant_glob(['*.cpp', '*.c',
                                          'util/*.c', 'util/*.cpp',
                                          'tools/*.c', 'tools/*.cpp',
                                          'json/jsoncpp.cpp',
                                          'transport/**/*.c', 'transport/**/*.cpp'],
                                          excl=srcExcludes))


    embedSource = ['zcm.h', 'zcm_private.h', 'zcm.c', 'zcm-cpp.hpp', 'zcm-cpp-impl.hpp',
                   'zcm_coretypes.h', 'transport.h', 'nonblocking.h', 'nonblocking.c',
                   'transport/generic_serial_transport.h',
                   'transport/generic_serial_transport.c' ]

    if ctx.env.USING_THIRD_PARTY:
        embedSource.append('transport/third-party/embedded/**')

    embedSource = ctx.path.ant_glob(embedSource)
    embedSource.append(ctx.path.find_or_declare("../zcm.gitid"))

    ## Collect files for Embedded
    ctx(rule   = package_embedded,
        name   = 'embed-tar',
        source = embedSource,
        target = 'zcm-embed.tar.gz',
        color  = "PINK")

    ## Test the embedded export
    ctx(rule   = exec_test_embedded,
        source = 'zcm-embed.tar.gz',
        target = 'zcm-embed-tests',
        color  = "PINK",
        after  = 'embed-tar-finish')

    ctx.install_files('${PREFIX}/include/zcm',
                      ['zcm.h', 'zcm_coretypes.h', 'transport.h', 'transport_registrar.h',
                       'url.h', 'eventlog.h', 'zcm-cpp.hpp', 'zcm-cpp-impl.hpp',
                       'transport_register.hpp', 'message_tracker.hpp'])

    ctx.install_files('${PREFIX}/include/zcm/tools',
                      ['tools/IndexerPlugin.hpp',
                       'tools/TranscoderPlugin.hpp'])

    ctx.install_files('${PREFIX}/include/zcm/util', 'util/Filter.hpp')

    ctx.install_files('${PREFIX}/include/zcm/json',
                      ['json/json.h', 'json/json-forwards.h'])

    ctx.install_files('${PREFIX}/include/zcm/transport',
                      ['transport/generic_serial_transport.h'])

    ctx.recurse('util')

    if ctx.env.USING_JAVA:
        ctx.recurse('java');

    if ctx.env.USING_NODEJS:
        ctx.recurse('js');

    if ctx.env.USING_PYTHON:
        ctx.recurse('python')

    if ctx.env.USING_CXXTEST:
        ctx.cxxtest(use = ['zcm', 'testzcmtypes'])

def package_embedded(tsk):
    gen = tsk.generator
    bld = gen.bld


    outfile = bld.path.get_bld().abspath() + '/' + tsk.outputs[0].relpath()
    outdir = re.sub('\.tar.gz$', '', outfile)

    src = ''
    for f in tsk.inputs:
        src += os.path.relpath(f.abspath(), bld.path.abspath()) + ' '

    cmd = 'cd {0} && rm -rf {1} && mkdir -p {1}/zcm && cp --parents {2} {1}/zcm/ && \
           {0}/scripts/prepend-embed-guards.sh {1}/zcm && rm -rf {1}/zcm/*.old && \
           tar -czf {3} -C {1} zcm'.format(bld.path.abspath(), outdir, src, outfile)

    ret = tsk.exec_command(cmd)
    if ret is not 0:
        raise WafError('Unable to package embedded tarball')

    return 0

def exec_test_embedded(tsk):
    src = tsk.inputs[0].abspath()
    blddir =  os.path.dirname(src)
    testdir = blddir + '/test-embed'
    cmd = 'rm -rf {0} && mkdir {0} && cd {0} && tar -xf {1} && ' \
          'cc -std=c89 -I ./zcm -DZCM_EMBEDDED -c zcm/zcm/*.c && ' \
          'echo "embed passed" > {2}' \
          .format(testdir, src, tsk.outputs[0].abspath())

    ret = tsk.exec_command(cmd)
    if ret is not 0:
        raise WafError('Embedded build failed, check embedded core files for C89 compliance')
    return ret
