
<!DOCTYPE html>
<html lang='en-us'>
  <head>
    <meta charset='UTF-8'>
    <title>tools</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' href='../stylesheets/normalize.css' media='screen'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel='stylesheet' type='text/css' href='../stylesheets/stylesheet.css' media='screen'>
    <link rel='stylesheet' type='text/css' href='../stylesheets/github-light.css' media='screen'>
  </head>
  <body>
    <section class='page-header'>
      <section style='cursor:pointer' onclick='window.location="../index.html";'>
        <h1 class='project-name'>Zcm</h1>
        <h2 class='project-tagline'>Zero Communications and Marshalling</h2>
      </section>
      <a href='https://github.com/ZeroCM/zcm' class='btn'>View on GitHub</a>
      <a href='https://github.com/ZeroCM/zcm/actions/workflows/build.yml' class='btn'>Monitor Builds</a>
      <a href='https://discord.gg/T6jYM3eMjw' class='btn'>Chat with the team</a>
      <a href='https://groups.google.com/forum/#!forum/zcm-users' class='btn'>Ask a Question</a>
      <a href='https://github.com/ZeroCM/zcm/zipball/master' class='btn'>Download .zip</a>
      <a href='https://github.com/ZeroCM/zcm/tarball/master' class='btn'>Download .tar.gz</a>
    </section>

    <section class='main-content'>
<h1>ZCM Tools</h1>

<p>ZCM ships with a convenient set of debugging and monitoring tools. In this section
we demonstrate the usage of these tools.</p>

<h3>Spy</h3>

<h5>To mark for build: <code>$./waf configure --use-java</code></h5>

<p>Since ZCM makes data decoupling so easy, developers tend to build applications in
several modules/processes and tie them together with ZCM message passing. In this
model, a lot of the debugging takes place at the message-passing level. Often
it's desirable to inspect/spy the messages in transit. This can be accomplished
using the <code>zcm-spy</code> tool. Note that you must have your types "compiled" into a
java jar and that jar must be listed in your <code>CLASSPATH</code> for <code>zcm-spy</code> to be able
to decode messages.</p>

<h3>Spy Lite</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>Sometimes developers don't have access to a display environment to run <code>zcm-spy</code>.
The terminal-based <code>zcm-spy-lite</code> is provided for exactly that situation.
<code>zcm-spy-lite</code> is a lite version of zcm spy that runs entirely from the terminal.
You can view message traffic and inspect message data all in a display-less
environment. To use <code>zcm-spy-lite</code> you need to tell it where to listen for messages
and where it can find a shared library containing the zcmtypes you would like it to
be able to decode. For an example on how to compile the shared library see the example further down.</p>

<h3>Logger</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>It is often desirable to record the messaging data events and record them for later
debugging. On a robotics system this is very important because often the developer
cannot debug in real-time nor deterministically reproduce bugs that have previously
occurred. By recording live events, debugging can be done after an issue occurs.
ZCM ships with a built-in logging API using <code>zcm/eventlog.h</code>. ZCM also provides
a stand-alone process <code>zcm-logger</code> that records all events it receives on the
specified transport.</p>

<h3>Log Player</h3>

<p>After capturing a ZCM log, it can be <em>replayed</em> using the <code>zcm-logplayer</code> tool.
This tool republishes the events back onto a ZCM transport. For here, any ZCM
subscriber application can receive the data exactly as it would have live! This
tool, combined with the logger creates a powerful development approach for
systems with limited debug-ability. <code>zcm-logplayer</code> also allows for playback
directly into an output log file. This might seem strange at first since <code>cp</code>
would accomplish the same end goal; however, <code>zcm-logplayer</code> also comes with a
meta file interface indicated by a file with a <code>.jslp</code> file extension. This file
specifies certain playback behavior. Currently supported functionality includes
the ability to whitelist, blacklist, or specify certain channels to be played
back. Other functionality includes the ability to only start playback of the
log after a certain amount of time has elapsed, or after the first message has
been broadcasted on a specified channel. A definition of a <code>jslp</code> file follows:</p>

<pre><code>{
    "FILTER" : {
        "type"     : "channels",
        "mode"     : "whitelist" | "blacklist" | "specified",
        "channels" : { "MODEL" : false }
    },
    "START" : {
        "mode"    : "channel" | "us_delay",
        "channel" | "us_delay" : "COMMAND_1_RX" | number_of_us
    }
}
</code></pre>

<p>see examples/tools/logplayer/example.log.jslp for more examples.</p>

<h3>Log Player GUI</h3>

<h5>To mark for build: <code>$./waf configure --use-java</code></h5>

<p>This is similar to <code>zcm-logplayer</code> but is a GUI-based tool. Launch <code>zcm-logplayer-gui</code>
to play back a log interactively. Speed up/slow down playback, play/pause,
scrub through the log, make bookmarks, mark sections to play on repeat,
export log snippets, all from one lightweight and easy to use tool.</p>

<h3>Bridge</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>When architecting a system that uses zcm, you might want to use multiple
transports. <code>zcm-bridge</code> allows you to bridge traffic between two
transports essentially subscribing to traffic on one transport, republishing it
on another, and vice versa</p>

<h3>Repeater</h3>

<p><code>zcm-repeater</code> is almost identical to <code>zcm-bridge</code> but is unidirectional.
It takes traffic on one transport and channel and rebroadcasts it to a
new channel</p>

<h3>Spy Peek</h3>

<p><code>zcm-spy-peek</code> is an extremely lightweight tool that simply prints when a message
is received. It's intended to be a sanity check tool to help diagnose when issues
arrise sending data from point A to point B. Running <code>zcm-spy-peek</code> while also
running the example publisher would result in the following printing to the screen:</p>

<pre><code>Message received on channel: "EXAMPLE"
Message received on channel: "EXAMPLE"
Message received on channel: "EXAMPLE"
...
</code></pre>

<!-- ADD MORE HERE -->

<h2>ZCM Tools Example</h2>

<p>For this example we'll build a small application which will count up from zero and
publish its new value on a channel named "COUNT".
First we need to define the ZCM message type for counting (count_t.zcm):</p>

<pre><code>struct count_t
{
    int32_t val;
}
</code></pre>

<p>Now because we want <code>zcm-spy-lite</code> to be able to decode our message, we need
to generate the bindings with extra type information:</p>

<pre><code>zcm-gen -c count_t.zcm --c-typeinfo
</code></pre>

<p>The <code>--c-typeinfo</code> flag is to include type introspection in the output zcmtype
source files. This means that auto-gen functions are included in the output type
to allow <code>zcm-spy-lite</code> to lookup the name and fields of the type from that type's
hash. It is only recommended if plan on using <code>zcm-spy-lite</code>. If you need to save
on size or if you don't care to use <code>zcm-spy-lite</code>, you can omit this flag.</p>

<p>Next up we need to write the source code for the publisher application itself (publish.c):</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;zcm/zcm.h&gt;
#include &lt;count_t.h&gt;

int main(int argc, char *argv[])
{
    zcm_t *zcm = zcm_create("ipc");
    count_t cnt = {0};

    while (1) {
        count_t_publish(zcm, "COUNT", &amp;cnt);
        cnt.val++;
        usleep(1000000); /* sleep for a second */
    }

    zcm_destroy(zcm);
    return 0;
}
</code></pre>

<p>Building and running the publisher:</p>

<pre><code>cc -o publish -I. publish.c count_t.c -lzcm
./publish
</code></pre>

<p>Building the shared library for <code>zcm-spy-lite</code></p>

<pre><code>cc -c -fpic count_t.c
cc -shared -o libzcmtypes.so count_t.o
</code></pre>

<p>Now that you have a shared library of your zcmtypes, you need to point
<code>zcm-spy-lite</code> to the folder where that library is stored. Much like
LD_LIBRARY_PATH is used to help your system find the paths to shared libraries
it needs to run programs, ZCM_SPY_LITE_PATH is used to point <code>zcm-spy-lite</code>
to the shared library.</p>

<pre><code>ZCM_SPY_LITE_PATH=&lt;full path to shared library&gt;
</code></pre>

<p>To make that environment variable load each time you open a new terminal, you
can add it to the bottom of your shell profile. For bash this would be adding
the following line to the bottom of your ~/.bashrc</p>

<pre><code>export ZCM_SPY_LITE_PATH=&lt;full path to shared library&gt;
</code></pre>

<p>We can now <em>spy</em> on the ZCM traffic with:</p>

<pre><code>zcm-spy-lite --zcm-url ipc
</code></pre>

<p>This will show an overview of all ZCM channels <code>zcm-spy-lite</code> have received
messages on. In this example only one channel is in use, but in real applications
many tens of channels might be in use at once.
For each channel you can see the total amount of received messages and the current
frequency. To inspect the messages of a specific channel press <code>-</code> and type the
number left of the channel name. For quick access to the first 9 channels, just
press the number on your keyboard directly. You will now be able to see the last
message transmitted on the channel. To go back to the overview press <code>ESC</code></p>

<p>Instead of monitoring the messages in real-time you can also record them for later
review or playback using the <code>zcm-logger</code>. To record the ZCM messages for a few seconds:</p>

<pre><code>zcm-logger --zcm-url ipc
</code></pre>

<p>This will produce a ZCM log file in the current directory
named with the pattern: <code>zcmlog-{YEAR}-{MONTH}-{DAY}.00</code></p>

<p>We can <em>replay</em> these captured events using the <code>zcm-logplayer</code> tool:</p>

<pre><code>zcm-logplayer --zcm-url ipc zcmlog-*.00
</code></pre>

<p>The replay tool alone is not very interesting until we combine it
with another application that will receive the data. For this purpose
we can use the <code>zcm-spy-lite</code> tool, running it before the replay tool:</p>

<pre><code>zcm-spy-lite --zcm-url ipc &amp;
zcm-logplayer --zcm-url ipc zcmlog-*.00
</code></pre>

<h2>Advanced Tools</h2>

<h3>CsvWriter</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>Sometimes it is useful to convert either a zcmlog or live zcm data into csv format.
This tool, launched via</p>

<pre><code>zcm-csv-writer
</code></pre>

<p>does this for you. See command line options for how to customize the output.</p>

<h3>CsvReader</h3>

<h5>To mark for build: <code>$./waf configure --use-java</code></h5>

<p>Sometimes it is useful to convert a csv into a zcmlog.
This tool, launched via</p>

<pre><code>zcm-csv-reader
</code></pre>

<p>does this for you. There is currently no default format that this reader will
be able to read in, however you may write your own CsvReaderPlugin for
custom csv parsing. Examples are provided in the examples directory in zcm.</p>

<h3>Transcoder</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>As explained in <a href="zcmtypesys.html">type generation</a>, modifying a zcmtype changes
that types hash and therefore invalidates all old logs you may have. However,
sometimes it may be desirable to add a field to a type without invalidating all
prior logs. To do this we provide a log transcoder launched via</p>

<pre><code>zcm-log-transcoder
</code></pre>

<p>and the TranscoderPlugin interface so you may define the mapping from old log
to new log. This tool can even let you convert between completely different types</p>

<h3>Indexer</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>This tool was designed to make programmatically working with zcm logs faster.
The purpose of this tool is best explained with an example.</p>

<p>Let's say that you have a log taken from a submersible ROV. Included in the log are messages
containing the beacon localization coordinates of the robot, and images the robot took
throughout the mission.</p>

<p>So what do you do if you want to extract all of the images that are 10m or more below the
surface? And better yet, what if you want them to be sorted in height order?</p>

<p>Well assuming you've gone through the tutorial, you already know how to programmatically
subscribe to zcm traffic; you could write a quick python/java/c/c++/{insert favorite
supported language here} program to subscribe to data and do the matching or filtering,
compile and run your program, and then use <code>zcm-logplayer</code> to play your log back while
your program is running.</p>

<p>If you were brave enough to dive into the code base already, you might already know about
the zcm log support in each language, and you'd be able to write a program that opens the log
and works with it directly (sans subscriptions). You would write a script in the language of
your choice that opens the log and attempts to match coordinate messages to picture
messages based on the times at which the measurements were taken. You would then filter
out all pairs that are above 10m deep, and finally sort the data in ascending depth order.</p>

<p>But what if you don't want to replicate information that's already stored in your log?
Better yet, what if you're not sure what you're going to want to do with the data
in your log? What if you're on an analytics team where each member is playing with different
data from the log? Do you replicate the log once for each member?</p>

<p>Sure, why not!</p>

<p>That answer is fine while your logs are small in size and number, but what if your
team is analyzing thousands of logs that are each gigabytes large?
Time and space become of the essence.</p>

<p>Let's go back to the previous example. However this time, instead of extracting the
image messages with the desired characteristics from the log, let's just save
their index in the log. Think of a log as a giant array of events. If we want to
remember that event number 46 is of importance, we store the number 46 in our index file.
When we pair the index information with the log itself, we have the ability to
directly jump to specific events in the log.</p>

<p>This is where <code>zcm-log-indexer</code> comes in.
<code>zcm-log-indexer</code> implements the code that opens the log, filters and
sorts the content events, and outputs a file containing the offset index
(encoded in json format). By default, <code>zcm-log-indexer</code> outputs an index file
that contains the offsets of each message type in the log sorted in timestamp order.
An interface is exposed so you can provide "plugins" to the indexer tool that
specify other ways you'd like logs to be indexed. The indexer will index logs by
every available plugin. Take a look at <code>zcm/tools/IndexerPlugin.hpp</code> for the plugin
interface and for an example custom plugin.</p>

<p>So let's go ahead and use <code>zcm-log-indexer</code>. But this time, let's use a simpler example.
In the case of a logfile taken by our ROV, we might want to extract all images in the log
in timestamp order. But we don't want to crawl through the log looking for image messages.
Assuming our log file is called <code>zcm.log</code>, we run the following command:</p>

<pre><code>zcm-log-indexer -l zcm.log -o zcm.dbz -t types.so -r
</code></pre>

<p>Note that the <code>-r</code> flags makes the output <code>zcm.dbz</code> file readable for humans.
After running the above command, the output index file might look like this:</p>

<pre><code>{
    "timestamp" : {
        "IMAGES" : {
            "image_t" : [
                "0",
                "1001000",
                "2002000",
                ...
                "37037000"
            ]
        },
        "BEACON_COORDS" : {
            "beacon_t" : [
                "1000000",
                "1000100",
                "1000200",
                "1000300",
                ...
                "37036900"
            ]
        }
    }
}
</code></pre>

<p>Notice that the file is first sorted by plugin name. This is the standard behavior
of <code>zcm-log-indexer</code>. Each plugin specifies its "name" as part of it's implementation.
The output of that plugin is always held in a high level json object whose key is
the plugin's name. In this case, the plugin's name is "timestamp".
After that point, the plugin specifies the rest of the organization of its json
index object. In the default case, the timestamp plugin organizes its output first
by channel name, then by zcm type name, but custom plugins are free to organize as
they see fit. The API through which custom plugins specify their organization is
specified in the base <code>IndexerPlugin.hpp</code> class. See that file for more information.</p>

<p>Now that we have both the zcm log and this index file, we can use it in whatever
zcm-supported language we please. Let's write a quick python script to print the times
of each image in our index in the order provided by the index.</p>

<pre><code>import sys
sys.path.insert(0, './build/types/')
from image_t import image_t

from zerocm import ZCM, LogFile, LogEvent
log = LogFile('zcm.log', 'r')

import json
with open('zcm.dbz') as indexFile:
    index = json.load(indexFile)

i = 0
while i &lt; len(index['timestamp']['IMAGES']['image_t']):
    evt = log.readEventOffset(int(index['timestamp']['IMAGES']['image_t'][i]))
    image = image_t.decode(evt.getData())
    print image.name + ": " + str(image.timestamp)
</code></pre>

<p>If you're still confused as to exactly how to use the tool, that's expected.
Head on over to the <code>examples</code> part of the repo and take a look at a custom plugin
in <code>examples/cpp/CustomIndexerPlugin.cpp</code> and then how to use it to quickly
traverse logs in <code>examples/python/indexer_test.py</code></p>

<p>When working with custom plugins, your launch command might looks like so:</p>

<pre><code>zcm-log-indexer -l zcm.log -o zcm.dbz -t types.so -p plugins.so
</code></pre>

<p>To tell <code>zcm-log-indexer</code> about your custom plugins and zcmtypes, you simply
compile a shared library and pass it to the tool via a command line argument.
You can also use the environment variables mentioned in the <code>--help</code> section
of <code>zcm-log-indexer</code> for specifying the <code>types.so</code> and <code>plugins.so</code> libraries.
Compiling a shared library is as easy as:</p>

<pre><code>g++ -std=c++11 -fPIC -shared CustomPlugin.cpp -o plugins.so
</code></pre>

<h3>Filter</h3>

<h5>To mark for build: <code>$./waf configure --use-elf</code></h5>

<p>Sometimes you may want to filter a zcm log down to only certain events.
To do this, we provide a tool that allows you to define on regions of a log
that you would like to keep.
This tool, launched via</p>

<pre><code>zcm-log-filter
</code></pre>

<p>does this by providing a rich command line interface through which you can
specify multiple regions with complex begin and end conditions.
Refer to the usage docs (<code>zcm-log-filter -h</code>) for the most up-to-date usage.</p>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73394372-1', 'auto');
  ga('send', 'pageview');

</script>
</section> </body> </html>
