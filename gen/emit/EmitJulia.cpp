#include <iostream>
#include <sstream>

#include "Common.hpp"
#include "Emitter.hpp"
#include "GetOpt.hpp"
#include "ZCMGen.hpp"

#include "util/StringUtil.hpp"
#include "util/FileUtil.hpp"

using namespace std;

void setupOptionsJulia(GetOpt& gopt)
{
    gopt.addString(0, "julia-path", ".", "Julia destination directory");
}

static string dotsToSlashes(const string& s)
{
    return StringUtil::replace(s, '.', '/');
}

// Some types do not have a 1:1 mapping from zcm types to native Julia storage types.
static string mapTypeName(const string& t)
{
    if      (t == "int8_t")   return "Int8";
    else if (t == "int16_t")  return "Int16";
    else if (t == "int32_t")  return "Int32";
    else if (t == "int64_t")  return "Int64";
    else if (t == "byte")     return "UInt8";
    else if (t == "float")    return "Float32";
    else if (t == "double")   return "Float64";
    else if (t == "string")   return "String";
    else if (t == "boolean")  return "Bool";
    else {
        return t;
    }
}

struct EmitJulia : public Emitter
{
    ZCMGen& zcm;
    ZCMStruct& ls;

    EmitJulia(ZCMGen& zcm, ZCMStruct& ls, const string& fname):
        Emitter(fname), zcm(zcm), ls(ls) {}

    void emitAutoGeneratedWarning()
    {
        emit(0, "# THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY");
        emit(0, "# BY HAND!!");
        emit(0, "#");
        emit(0, "# Generated by zcm-gen");
        emit(0, "#");
        emit(0, "");
    }

    void emitComment(int indent, const string& comment)
    {
        if (comment == "")
            return;

        auto lines = StringUtil::split(comment, '\n');
        if (lines.size() == 1) {
            emit(indent, "# %s", lines[0].c_str());
        } else {
            for (auto& line : lines) {
                emitStart(indent, "#");
                if (line.size() > 0)
                    emitContinue("%s", line.c_str());
                emitEnd("");
            }
        }
    }

    void emitPackageNamespaceStart()
    {
        // output namespace declaration
        auto namespaces = StringUtil::split(ls.structname.fullname, '.');
        for (size_t i = 0; i < namespaces.size()-1; i++)
            emit(0, "Module %s", namespaces[i].c_str());
    }

    void emitPackageNamespaceClose()
    {
        auto namespaces = StringUtil::split(ls.structname.fullname, '.');
        for (size_t i = 0; i < namespaces.size()-1; i++)
            emit(0, "end\n");
    }

    void emitHeaderStart()
    {
        const char *tn = ls.structname.fullname.c_str();
        const char *sn = ls.structname.shortname.c_str();

        emitAutoGeneratedWarning();

        bool haveRecursive = false;
        // include header files for other ZCM types
        for (auto& lm : ls.members) {
            auto& mtn = lm.type.fullname;
            if (!ZCMGen::isPrimitiveType(mtn) && mtn != tn) {
                emit(0, "include(\"%s.jl\")", dotsToSlashes(mtn).c_str());
                haveRecursive = true;
            }
        }

        emit(0, "");
        emitPackageNamespaceStart();

        // define the class
        emitComment(0, ls.comment);
        emit(0, "type %s", sn);
        emit(0, "");

        // data members
        if (ls.members.size() > 0) {
            emit(1, "# **********************");
            emit(1, "# Members");
            emit(1, "# **********************");
            for (auto& lm : ls.members) {
                auto& mtn = lm.type.fullname;
                emitComment(2, lm.comment);
                string mappedTypename = mapTypeName(mtn);
                int ndim = (int)lm.dimensions.size();
                if (ndim == 0) {
                    emit(1, "%-30s::%s", lm.membername.c_str(), mappedTypename.c_str());
                } else {
                    emit(1, "%-30s::Array{%s,%u}", lm.membername.c_str(),
                                                   mappedTypename.c_str(), ndim);
                }
            }
            emit(0, "");
        }

        // constants
        if (ls.constants.size() > 0) {
            emit(0, "");
            emit(1, "# **********************");
            emit(1, "# Constants");
            emit(1, "# **********************");
            for (auto& lc : ls.constants) {
                assert(ZCMGen::isLegalConstType(lc.type));
                string mt = mapTypeName(lc.type);
                emit(1, "%-30s::%s", lc.membername.c_str(), mt.c_str(), lc.valstr.c_str());
            }
            emit(0, "");
        }

        emit(1, "# **********************");
        emit(1, "# Functions");
        emit(1, "# **********************");

        emit(1, "%-30s::Function", "_get_hash_recursive");
        emit(1, "%-30s::Function", "getHash");
        emit(1, "%-30s::Function", "encode");
        emit(1, "%-30s::Function", "decode");
        emit(0, "");
        emit(1, "function %s()", sn);
        emit(0, "");
        emit(2, "instance = new();");
        emit(0, "");

        // data members
        if (haveRecursive) {
            emit(2, "# **********************");
            emit(2, "# Members");
            emit(2, "# **********************");
            for (auto& lm : ls.members) {
                auto& mtn = lm.type.fullname;
                if (!ZCMGen::isPrimitiveType(mtn) && mtn != tn) {
                    string mappedTypename = mapTypeName(mtn);
                    int ndim = (int)lm.dimensions.size();
                    if (ndim == 0) {
                        emit(2, "%-30s = %s()", lm.membername.c_str(), mappedTypename.c_str());
                    } else {
                        emit(2, "%-30s = Array{%s,%u}", lm.membername.c_str(),
                                                        mappedTypename.c_str(), ndim);
                    }
                }
            }
            emit(0, "");
        }

        // constants
        if (ls.constants.size() > 0) {
            emit(2, "# **********************");
            emit(2, "# Constants");
            emit(2, "# **********************");

            for (auto& lc : ls.constants) {
                assert(ZCMGen::isLegalConstType(lc.type));
                string mt = mapTypeName(lc.type);
                emitStart(2, "instance.%s::%s = ", lc.membername.c_str(), mt.c_str());
                if (lc.isFixedPoint()) {
                    size_t numBits = ZCMGen::getPrimitiveTypeSize(lc.type) * 8;
                    emitContinue("(((%s) & 0x%" PRIx64 ") != 0)",
                                 lc.valstr.c_str(), (1L << (numBits - 1)));
                    emitEnd(" ? ~%s(~%s) : %s", mt.c_str(),
                            lc.valstr.c_str(), lc.valstr.c_str());
                } else {
                    emitEnd("%s", lc.valstr.c_str());
                }
            }
            emit(0, "");
        }
    }

    void emitHeaderEnd()
    {
        emit(2, "return instance");
        emit(1, "end");
        emit(0, "");
        emit(0, "end");
        emit(0, "");
        emitPackageNamespaceClose();
    }

    void emitGetHash()
    {
        auto& sn_ = ls.structname.shortname;
        auto *sn = sn_.c_str();

        emit(2, "_hash::Int64 = 0");

        emit(2, "instance._get_hash_recursive = function(parents::Array{String})");
        emit(3,     "if _hash != 0; return _hash; end");
        emit(3,     "if \"%s\"::String in parents; return 0; end", sn);
        for (auto& lm : ls.members) {
            if (!ZCMGen::isPrimitiveType(lm.type.fullname)) {
                emit(3, "newparents::Array{String} = [parents[:]; \"%s\"::String];", sn);
                break;
            }
        }
        emitStart(3, "hash::UInt64 = 0x%" PRIx64 " ", ls.hash);
        for (auto &lm : ls.members) {
            auto& mn = lm.membername;
            if (!ZCMGen::isPrimitiveType(lm.type.fullname)) {
                const char *ghr = "_get_hash_recursive(newparents)";
                if (lm.type.fullname == ls.structname.fullname) {
                    emitContinue("+ %s.%s", mn.c_str(), ghr);
                } else {
                    if (lm.type.package != "")
                        emitContinue("+ %s.%s.%s", lm.type.package.c_str(), mn.c_str(), ghr);
                    else
                        emitContinue("+ %s.%s", mn.c_str(), ghr);
                }
            }
        }
        emitEnd("");

        emit(3,     "hash = (hash << 1) + ((hash >>> 63) & 0x01)");
        emit(3,     "_hash = ((hash & 0x8000000000000000) != 0) ? ~Int64(~hash) : Int64(hash)");
        emit(3,     "return _hash");
        emit(2, "end");
        emit(1, "");
        emit(2, "instance.getHash = function()", sn);
        emit(3,     "return instance._get_hash_recursive(Array{String,1}([]))");
        emit(2, "end");
        emit(1, "");
    }

    void emitEncode()
    {
        emit(2, "instance.encode = function()");
        emit(2, "end");
        emit(1, "");
    }

    void emitDecode()
    {
        emit(2, "instance.decode = function(data::Array{UInt8,1})");
        emit(2, "end");
        emit(1, "");
    }

    void emitHeader()
    {
        emitHeaderStart();
        emitGetHash();
        emitEncode();
        emitDecode();
        emitHeaderEnd();
    }
};

int emitJulia(ZCMGen& zcm)
{
    if (zcm.gopt->getBool("little-endian-encoding")) {
        printf("Julia does not currently support little endian encoding\n");
        return -1;
    }

    // iterate through all defined message types
    for (auto& ls : zcm.structs) {
        string tn = dotsToSlashes(ls.structname.fullname);

        // compute the target filename
        string hpath = zcm.gopt->getString("julia-path");
        string headerName = hpath + (hpath.size() > 0 ? "/" : ":") + tn +".jl";

        // generate code if needed
        if (zcm.needsGeneration(ls.zcmfile, headerName)) {
            FileUtil::makeDirsForFile(headerName);
            EmitJulia E{zcm, ls, headerName};
            if (!E.good()) return -1;
            E.emitHeader();

        }
    }

    return 0;
}
